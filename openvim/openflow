#!/usr/bin/env python
# -*- coding: utf-8 -*-
# PYTHON_ARGCOMPLETE_OK

##
# Copyright 2015 Telefónica Investigación y Desarrollo, S.A.U.
# This file is part of openmano
# All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.
#
# For those usages not covered by the Apache License, Version 2.0 please
# contact with: nfvlabs@tid.es
##

'''
This program is useful to interact directly with Openflow Controllers
to clear rules, add and delete rules, list rules, etc.
'''

__author__="Gerardo Garcia, Alfonso Tierno"
__date__ ="$09-oct-2014 09:09:48$"

#import time
import os
import argparse
import argcomplete
import floodlight as FL
import ODL
import yaml
import requests
from openflow_thread import change_db2of

def of_switches(args):
    r,c = ofconnector.get_of_switches()
    if r<0:
        print c
    else: 
        for s in c:
            print " %s %s" % (s[0], s[1])
    return

def of_list(args):
    r,c = ofconnector.get_of_rules(not args.no_translate)
    if r<0:
        print c
        return
    if args.verbose > 0:
        print yaml.safe_dump(c, indent=4, default_flow_style=False)
        return

    print "       switch           priority        name                             ingress_port    dst_mac       vlan_id  actions"
    for name,rule in c.iteritems():
        action_list=[]
        for action in rule["actions"]:
            action_list.append(action[0]+"="+str(action[1]))
        if "vlan_id" in rule:
            vlan=str(rule["vlan_id"])
        else:
            vlan="any"
        print "%s  %s  %s  %s  %s  %s  %s" % \
            (rule["switch"], str(rule["priority"]).ljust(6), name.ljust(40), rule["ingress_port"].ljust(8), \
            rule.get("dst_mac","any").ljust(18), vlan.ljust(4), ",".join(action_list) )
    return

def of_clear(args):
    if not args.force:
        r = raw_input("Clear all Openflow rules (y/N)? ")
        if  not (len(r)>0  and r[0].lower()=="y"):
            return
    r,c = ofconnector.clear_all_flows()
    if r<0:
        print c
    return

#def of_dump(args):
#    args.verbose = 3
#    args.no_translate=False
#    of_list(args)
#    return

def of_reinstall(args):
    try:
        URLrequest = "http://%s:%s/openvim/networks/all/openflow" %(vim_host, vim_admin_port)
        openvim_response = requests.put(URLrequest)
        print openvim_response
        print openvim_response.text
        return
    except requests.exceptions.RequestException, e:
        return -1, " Exception GET at '"+URLrequest+"' " + str(e.message)

def of_install(args):
    try:
        f = open(args.file, "r")
        text = f.read()
        f.close()
        lines=text.split("\n")
        heads=lines[0].split()

        for line in lines[1:]:
            rule={}
            items= line.split()
            if len(items)==0 or items[0][0]=="#": #empty line or commented
                continue
            for i in range(0,len(items)):
                rule[ heads[i] ] = items[i]
            #TODO change to openflow format
            if rule["vlan_id"] == "any":
                del rule["vlan_id"]
            if rule["dst_mac"] == "any":
                del rule["dst_mac"]
            change_db2of(rule)
            r,c = ofconnector.new_flow(rule)
            if r<0:
                error="ERROR: "+c
            else:
                error="OK"
            print "%s  %s  %s  input=%s  dst_mac=%s  vlan_id=%s  %s" % \
                    (rule["switch"], rule["priority"].ljust(6), rule["name"].ljust(20), rule["ingress_port"].ljust(3), \
                     rule.get("dst_mac","any").ljust(18), rule.get("vlan_id","any").ljust(4), error )
        return
    except IOError, e:
        print " Error opening file '" + args.file + "': " + e.args[1]
    except yaml.YAMLError, exc:
        error_pos = ""
        if hasattr(exc, 'problem_mark'):
            mark = exc.problem_mark
            error_pos = " at position: (%s:%s)" % (mark.line+1, mark.column+1)
        print " Error yaml/json format error at " + error_pos


def of_add(args):
    rule={"name":args.name, "priority":args.priority,
          "ingress_port": args.inport
        }
    if args.matchvlan:
        rule["vlan_id"] = args.matchvlan
    if args.matchmac:
        rule["dst_mac"] = args.matchmac
    actions=[]
    if args.stripvlan:
        actions.append( ("vlan", None) )
    elif args.setvlan != None:
        actions.append( ("vlan", args.setvlan) )
    if args.outport:
        actions.append( ("out", args.outport) )
    rule["actions"] = actions
    r,c = ofconnector.new_flow(rule)
    if r<0:
        print c
    return

def of_delete(args):
    if not args.force:
        r = raw_input("Clear rule %s (y/N)? " %(args.name))
        if  not (len(r)>0  and r[0].lower()=="y"):
            return
    r,c = ofconnector.del_flow(args.name)
    if r<0:
        print c
    return

def config(args):
    print "OPENVIM_HOST: %s" %(vim_host)
    print "OPENVIM_ADMIN_PORT: %s" %(vim_admin_port)
    print "OF_CONTROLLER_TYPE: %s" %(of_controller_type)
    #print "OF_CONTROLLER_VERSION: %s" %(of_controller_version)
    print "OF_CONTROLLER_IP: %s" %(of_controller_ip)
    print "OF_CONTROLLER_PORT: %s" %(of_controller_port)
    print "OF_CONTROLLER_DPID: %s" %(of_controller_dpid)
    return

version="0.6"
global vim_host
global vim_admin_port
global of_controller_type
#global of_controller_version
global of_controller_ip
global of_controller_port
global of_controller_dpid
global ofconnector
   
if __name__=="__main__":
    #print "test_ofconnector version", version, "Jul 2015"
    #print "(c) Copyright Telefonica"
    
    vim_host = os.getenv('OPENVIM_HOST',"localhost")
    vim_admin_port = os.getenv('OPENVIM_ADMIN_PORT',"8085")
    of_controller_type = os.getenv('OF_CONTROLLER_TYPE',"floodlight")
    #of_controller_version = os.getenv('OF_CONTROLLER_VERSION',"0.90")
    of_controller_ip = os.getenv('OF_CONTROLLER_IP',"localhost")
    of_controller_port = os.getenv('OF_CONTROLLER_PORT',"7070")
    of_controller_dpid = os.getenv('OF_CONTROLLER_DPID','00:01:02:03:e4:05:e6:07')
    
    main_parser = argparse.ArgumentParser(description='User program to interact with Openflow controller')
    main_parser.add_argument('--version', action='version', version='%(prog)s ' + version )
    
    #main_parser = argparse.ArgumentParser()
    subparsers = main_parser.add_subparsers(help='commands')
    
    config_parser = subparsers.add_parser('config', help="prints configuration values")
    config_parser.set_defaults(func=config)
    
    add_parser = subparsers.add_parser('add', help="adds an openflow rule")
    add_parser.add_argument('--verbose', '-v', action='count')
    add_parser.add_argument("name", action="store", help="name of the rule")
    add_parser.add_argument("inport", action="store", type=int, help="match rule: ingress-port")
    add_parser.add_argument("outport", action="store", type=int, help="action: egress-port")
    add_parser.add_argument("--priority", action="store", type=int, help="rule priority")
    add_parser.add_argument("--matchmac", action="store", help="match rule: mac address")
    add_parser.add_argument("--matchvlan", action="store", type=int, help="match rule: vlan id")
    add_parser.add_argument("--stripvlan", action="store_true", help="action: strip vlan")
    add_parser.add_argument("--setvlan", action="store", type=int, help="action: sets vlan id")
    add_parser.set_defaults(func=of_add)
    
    delete_parser = subparsers.add_parser('delete', help="delete an openflow rule")
    delete_parser.add_argument('--verbose', '-v', action='count')
    delete_parser.add_argument("-f", "--force", action="store_true", help="force deletion without asking")
    delete_parser.add_argument("name", action="store", help="name of the rule to be deleted")
    delete_parser.set_defaults(func=of_delete)
    
    switches_parser = subparsers.add_parser('switches', help="list all switches controlled by the OFC")
    switches_parser.add_argument('--verbose', '-v', action='count')
    switches_parser.set_defaults(func=of_switches)

    list_parser = subparsers.add_parser('list', help="list openflow rules")
    list_parser.add_argument('--verbose', '-v', action='count')
    list_parser.add_argument("--no-translate", "-n", action="store_true", help="Skip translation from openflow index to switch port name")
    list_parser.set_defaults(func=of_list)

 #   dump_parser = subparsers.add_parser('dump', help="dump openflow rules")
 #   dump_parser.set_defaults(func=of_dump)
    
    clear_parser = subparsers.add_parser('clear', help="clear all openflow rules")
    clear_parser.add_argument("-f", "--force", action="store_true", help="forces deletion without asking")
    clear_parser.set_defaults(func=of_clear)

    install_parser = subparsers.add_parser('install', help="install openflow rules from file")
    install_parser.add_argument("file", action="store", help="file with rules generated using 'openflow list > rules.txt'")
    install_parser.set_defaults(func=of_install)

    reinstall_parser = subparsers.add_parser('reinstall', help="reinstall openflow rules from VIM rules")
    reinstall_parser.set_defaults(func=of_reinstall)

    argcomplete.autocomplete(main_parser)
    
    args = main_parser.parse_args()
    
    #floodlight_versions = ("0.90", "1.0", "1.1")
    #if of_controller_type == "floodlight" and of_controller_version not in floodlight_versions:
    #    print "Wrong Floodlight controller version. Supported versions: %" %str(floodlight_versions)
    #    exit()
    
    if of_controller_type == "floodlight":
        ofconnector = FL.FL_conn(of_controller_ip, of_controller_port, of_controller_dpid)
    elif  of_controller_type == "opendaylight":
        ofconnector = ODL.ODL_conn(of_controller_ip, of_controller_port, of_controller_dpid,"admin","admin")
    else:
        print "Wrong controller type"

    args.func(args)
    
    exit()


